RAILS_ENV=production bundle exec rake assets:precompile
git add public/assets
git commit -m "vendor compiled assets"
git push 
git push heroku master

# Routes
rake traceroute

# Style
rubocop
    https://github.com/bbatsov/rubocop/blob/master/manual/formatters.md
    https://www.dennyzhang.com/rubocop_errors
    http://rubocop.readthedocs.io/en/latest/basic_usage/
    https://github.com/bbatsov/rubocop/blob/master/manual/cops_metrics.md
rubocop --auto-gen-config #for config which you can edit
rubocop -a <file></file>
rubocop --format worst
rubocop --format offenses
rails_best_practices .

# Refactor bad code
rubycritic
reek
flog > flog_output.txt
flay

"Code that flay reports as similar is a good candidate for refactoring."

"FLOG: scores above 20 indicate the method may need refactoring, and above 60 is dangerous. "



Note that size: size is equivalent to :size => size.


Use helpers if you're working in a view (template) and you need to build a complex bit of HTML such as a <table>. Or, if you want to change some presentation data that's not connected to the database.

def truncate_html( html, options = {} )
  options[:length] = 35 unless options[:length]
  truncate( strip_tags( html ), options )
end

Use models when you're working with database objects, and you want to simplify the business logic.

  def one_day?
    start_date.to_s[0,9] == end_date.to_s[0,9]
  end  
Here's Helpers in the guides: http://api.rubyonrails.org/v5.1/classes/ActionController/Helpers.html

And here's Models: http://guides.rubyonrails.org/active_record_querying.html


TL;DR= Models is for database logic; Helpers are for view logic.

######
The Concern is a tool provided by the ActiveSupport lib for including modules in classes, creating mixins.

A good concern should be able to work in isolation, so it must be dependency-free. It should have a very concrete and limited responsibility. The kind of responsibilities for a concern should be framework or infrastructure related. That means that they shouldn’t contain business logic. Business logic is better modelled as abstractions (classes), rather than concerns. Value objects, services, repositories, aggregates or whatever artifact that fits better.
But even good concerns present software design problems. Concerns are a bit harder to test, since you need more arrangement. But maybe the most important problem is that concerns promote the is a relation between our classes. With theis a relation, an object inherits behaviour directly, so more and more responsibilites are aggregated to the object as long as we keep adding concerns. True seggregation of responsibilities come with has a relationship, either via composition or aggregation.
Finally, it’s hard to say what problem concerns solve. Every problem that concerns solve can be solved with composition or aggregation. Better than that, composition/aggregation solve the same problem but explicitly.

TL;DR= Concerns for code shared between controllers or between models. 


###

30
down vote
accepted
Classes are also objects in Ruby, so they can have their own instance variables which are called class instance variables.

@@world is a class variable
@insworld is a class instance variable
#index is an instance method
When you try to access @insworld in #index, Ruby searches for the instance variable in the A object (meaning A.new) because #index is an instance method.

But you defined @insworld as a class instance variable which means it is defined in the class object itself (meaning A).

The following code demonstrates:

class Hi
  @@a = 1 # class variable
  @b  = 2 # class instance variable

  def initialize
    @c = 3 # instance variable
  end

  def test # instance method, works on objects of class Hi
    puts @@a # => 1
    puts @b  # => nil, there is no instance variable @b
    puts @c  # => 3 # we defined this instance variable in the initializer
  end
end

Hi.class_variables        # => @@a
Hi.instance_variables     # => @b
Hi.new.instance_variables # => @c
# Hi is an object of class Class
# Hi.new is an object of class Hi
Keep in mind that all instance variables return nil if they don't exist.


### 


stuff - a local variable
@stuff - an object variable (one per object)
@@stuff - a class variable (just one for a whole class of objects)
$stuff - a global variable (just one for the program)

# returns if something is false
return unless <something></something>